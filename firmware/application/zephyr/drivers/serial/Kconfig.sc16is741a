# SPDX-License-Identifier: Apache-2.0

menuconfig UART_SC16IS741A
	bool "SC16IS741A serial driver"
	default y
	depends on DT_HAS_SC16IS741A_ENABLED
	depends on I2C
	select SERIAL_HAS_DRIVER
	select SERIAL_SUPPORT_INTERRUPT
	help
	  This option enables the SC16IS741A serial driver.
	  This driver can be used for the serial hardware
	  available on x86 boards.

if UART_SC16IS741A

config UART_SC16IS741A_LINE_CTRL
	bool "Serial Line Control for Apps"
	depends on UART_LINE_CTRL
	help
	  This enables the API for apps to control the serial line,
	  such as CTS and RTS.

	  Says n if not sure.

config UART_SC16IS741A_DRV_CMD
	bool "Driver Commands"
	depends on UART_DRV_CMD
	help
	  This enables the API for apps to send commands to driver.

	  Says n if not sure.

config UART_SC16IS741A_FIFO
	bool "Enable 64-bytes FIFO and auto flow control"
	help
	  This enables support for 64-bytes FIFO and automatic hardware
	  flow control

menu "SC16IS741A Workarounds"

config UART_SC16IS741A_WA_ISR_REENABLE_INTERRUPT
	bool "Re-enable interrupts by toggling IER at end of ISR"
	depends on UART_INTERRUPT_DRIVEN
	help
	  In some configurations (e.g. edge interrupt triggers),
	  an interruptible event occurs during ISR and the host interrupt
	  controller does not see the new event due to IIR is constantly
	  asserting interrupts. For example, the callback handles RX and
	  then TX. If another character comes in before end of TX processing
	  (TX interrupt still asserts while raising RX interrupt), the host
	  interrupt controller may not see this new event. So if needed,
	  the IER is being toggled to re-assert interrupts at the end of ISR
	  to nudge the host interrupt controller to fire the ISR again.

endmenu

endif # UART_SC16IS741A
